### –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã–µ –∏–¥–µ–∏ –∏ –∏—Ö —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—à–∏—Ä–∏–º –Ω–∞—à —Ç–µ–ª–µ—Å–∫–æ–ø –¥–æ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π –ö—Ä–∏–ø—Ç–æ-–ö–æ—Å–º–∏—á–µ—Å–∫–æ–π –û–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏–∏! –í–æ—Ç —á—Ç–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å:

```python
import numpy as np
import pygame
import sys
from pygame.locals import *
import math
from fastecdsa.curve import Curve
import noise
from PIL import Image
import io
import qrcode
import speech_recognition as sr
from transformers import pipeline
import torch
import random
from sklearn.cluster import DBSCAN

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PyGame
pygame.init()
WIDTH, HEIGHT = 1600, 900
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("–ö—Ä–∏–ø—Ç–æ-–ö–æ—Å–º–∏—á–µ—Å–∫–∞—è –û–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏—è")

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫—Ä–∏–≤–æ–π
_67 = Curve(name="_67", p=67, a=0, b=7, q=79, gx=2, gy=22)
G = _67.G
n = _67.q
d = 27  # –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á

# –®—Ä–∏—Ñ—Ç—ã
font_large = pygame.font.SysFont('Arial', 36, bold=True)
font_medium = pygame.font.SysFont('Arial', 24)
font_small = pygame.font.SysFont('Arial', 18)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è NLP –º–æ–¥–µ–ª–µ–π (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
try:
    recognizer = sr.Recognizer()
    generator = pipeline('text-generation', model='gpt2')
except:
    print("NLP –º–æ–¥–µ–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±—É–¥—É—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω—ã")

class CosmicCryptoObservatory:
    def __init__(self, d, n):
        self.d = d
        self.n = n
        self.focus_level = 0
        self.mode = "telescope"  # telescope, quantum, neural, poetry, hologram
        self.initialize_data()
        self.generate_poem()
        self.generate_hologram()
        
    def initialize_data(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏"""
        # –ì–∏–ø–µ—Ä–∫—É–±
        self.hypercube = []
        for ur in range(n):
            for uz in range(n):
                T = (ur * self.d + uz) % n
                Rx = T
                s = (ur + uz) % n
                self.hypercube.append((ur, uz, Rx, s))
        
        # –ö–æ–ª–ª–∏–∑–∏–∏
        collision_map = {}
        for i, point in enumerate(self.hypercube):
            key = (point[2], point[3])
            collision_map.setdefault(key, []).append(i)
        self.collision_points = [points for points in collision_map.values() if len(points) > 1]
        
        # –ù–µ–π—Ä–æ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        self.security_map = np.zeros((n, n))
        for ur in range(n):
            for uz in range(n):
                # –£–ø—Ä–æ—â—ë–Ω–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                self.security_map[ur, uz] = (ur * uz * self.d) % n / n
        
        # –ö–≤–∞–Ω—Ç–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        self.quantum_state = np.random.rand(8) + 1j * np.random.rand(8)
        self.quantum_state /= np.linalg.norm(self.quantum_state)
        
        # –ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–µ–∫—Ç–æ—Ä
        self.hologram_data = None
        
    def generate_poem(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ-–ø–æ—ç–∑–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–∞"""
        seed = f"–ö–ª—é—á {self.d}, –∫—Ä–∏–≤–∞—è –ø–æ—Ä—è–¥–∫–∞ {self.n}. "
        self.poem = seed + "–í —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ—Å—Ç—è—Ö –∫–æ–ª–ª–∏–∑–∏–π —Ä–æ–∂–¥–∞–µ—Ç—Å—è –Ω–æ–≤—ã–π —Å–º—ã—Å–ª. "
        self.poem += "–ö–≤–∞–Ω—Ç–æ–≤—ã–µ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏ —à–µ–ø—á—É—Ç —Ç–∞–π–Ω—ã —ç–ª–ª–∏–ø—Ç–∏—á–µ—Å–∫–∏—Ö –º–∏—Ä–æ–≤. "
        self.poem += "–û, –≥–∏–ø–µ—Ä–∫—É–±, —Ç–≤–æ—è —Ç–æ–ø–æ–ª–æ–≥–∏—è - —Å–∏–º—Ñ–æ–Ω–∏—è —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –±—ã—Ç–∏—è!"
        self.poem_lines = [self.poem[i:i+50] for i in range(0, len(self.poem), 50)]
        
    def generate_hologram(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è 3D –≥–æ–ª–æ–≥—Ä–∞–º–º—ã"""
        size = 128
        img = Image.new('RGB', (size, size))
        pixels = img.load()
        
        for x in range(size):
            for y in range(size):
                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–æ–Ω–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω—ã
                r = int(128 + 127 * math.sin(0.1 * x * self.d / n))
                g = int(128 + 127 * math.sin(0.1 * y * self.d / n))
                b = int(128 + 127 * math.sin(0.1 * (x + y) * self.d / n))
                pixels[x, y] = (r, g, b)
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏ PyGame
        self.hologram_surface = pygame.image.load(img_bytes)
        self.hologram_surface = pygame.transform.scale(self.hologram_surface, (300, 300))
        
    def voice_command(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö –∫–æ–º–∞–Ω–¥"""
        try:
            with sr.Microphone() as source:
                print("–°–ª—É—à–∞—é...")
                audio = recognizer.listen(source, timeout=3)
                text = recognizer.recognize_google(audio, language="ru-RU")
                print(f"–†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: {text}")
                
                if "–∫–ª—é—á" in text:
                    new_d = random.randint(1, n-1)
                    self.__init__(new_d, n)
                    return f"–ö–ª—é—á –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ {new_d}"
                elif "—Ä–µ–∂–∏–º" in text:
                    modes = ["—Ç–µ–ª–µ—Å–∫–æ–ø", "–∫–≤–∞–Ω—Ç", "–Ω–µ–π—Ä–æ", "–ø–æ—ç–∑–∏—è", "–≥–æ–ª–æ–≥—Ä–∞–º–º–∞"]
                    for mode in modes:
                        if mode in text:
                            self.mode = {"—Ç–µ–ª–µ—Å–∫–æ–ø": "telescope", "–∫–≤–∞–Ω—Ç": "quantum", 
                                        "–Ω–µ–π—Ä–æ": "neural", "–ø–æ—ç–∑–∏—è": "poetry", 
                                        "–≥–æ–ª–æ–≥—Ä–∞–º–º–∞": "hologram"}[mode]
                            return f"–†–µ–∂–∏–º –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ {mode}"
                elif "–ø–æ—ç–∑–∏—è" in text:
                    self.generate_poem()
                    return "–ù–æ–≤–∞—è –ø–æ—ç–º–∞ —Å–æ–∑–¥–∞–Ω–∞"
                
                return f"–í—ã–ø–æ–ª–Ω–µ–Ω–æ: {text[:20]}..."
        except Exception as e:
            return f"–û—à–∏–±–∫–∞: {str(e)}"
    
    def quantum_operation(self, gate):
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∫–≤–∞–Ω—Ç–æ–≤–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏"""
        if gate == "H":
            # Hadamard gate
            H = np.array([[1, 1], [1, -1]]) / np.sqrt(2)
            op = np.kron(np.kron(H, H), np.kron(H, H))
        elif gate == "X":
            # Pauli X
            X = np.array([[0, 1], [1, 0]])
            op = np.kron(np.kron(X, np.eye(2)), np.kron(np.eye(2), np.eye(2)))
        else:  # CNOT
            CNOT = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])
            op = np.kron(CNOT, np.eye(4))
        
        self.quantum_state = op.dot(self.quantum_state)
        return f"–ü—Ä–∏–º–µ–Ω–µ–Ω–∞ {gate}-–æ–ø–µ—Ä–∞—Ü–∏—è"
    
    def neural_analysis(self):
        """–ê–Ω–∞–ª–∏–∑ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å –ø–æ–º–æ—â—å—é –Ω–µ–π—Ä–æ—Å–µ—Ç–∏"""
        # –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –∫–æ–ª–ª–∏–∑–∏–π
        collision_coords = []
        for collision in self.collision_points:
            for idx in collision:
                ur, uz, Rx, s = self.hypercube[idx]
                collision_coords.append([ur, uz])
        
        if len(collision_coords) > 0:
            clustering = DBSCAN(eps=5, min_samples=2).fit(collision_coords)
            clusters = {}
            for i, label in enumerate(clustering.labels_):
                clusters.setdefault(label, []).append(collision_coords[i])
            
            # –û—Ü–µ–Ω–∫–∞ —É–≥—Ä–æ–∑—ã
            threat = 0
            for label, points in clusters.items():
                if label != -1:  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —à—É–º
                    threat += len(points) ** 1.5
            
            threat = min(1.0, threat / 100)
            return f"–£—Ä–æ–≤–µ–Ω—å —É–≥—Ä–æ–∑—ã: {threat:.2%}", threat
        return "–ù–µ—Ç –∫–æ–ª–ª–∏–∑–∏–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞", 0.0
    
    def update(self, focus_level):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏–∏"""
        self.focus_level = focus_level
        
    def render(self, surface):
        """–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Ç–µ–∫—É—â–µ–≥–æ —Ä–µ–∂–∏–º–∞"""
        if self.mode == "telescope":
            self.render_telescope(surface)
        elif self.mode == "quantum":
            self.render_quantum(surface)
        elif self.mode == "neural":
            self.render_neural(surface)
        elif self.mode == "poetry":
            self.render_poetry(surface)
        elif self.mode == "hologram":
            self.render_hologram(surface)
        
        # –û–±—â–∞—è –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.render_control_panel(surface)
    
    def render_telescope(self, surface):
        """–†–µ–∂–∏–º —Ç–µ–ª–µ—Å–∫–æ–ø–∞"""
        # –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
        surface.fill((10, 5, 30))
        
        # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–µ—Ä–Ω–∞—è –¥—ã—Ä–∞
        center_x, center_y = WIDTH // 2, HEIGHT // 2
        black_hole_radius = 50 + 20 * math.sin(pygame.time.get_ticks() / 1000)
        pygame.draw.circle(surface, (0, 0, 0), (center_x, center_y), black_hole_radius)
        
        # –ê–∫–∫—Ä–µ—Ü–∏–æ–Ω–Ω—ã–π –¥–∏—Å–∫
        for i in range(3):
            radius = black_hole_radius + 50 + i * 40
            pygame.draw.circle(surface, (100, 50, 200), (center_x, center_y), radius, 2)
        
        # –ö–æ–ª–ª–∏–∑–∏–∏ –∫–∞–∫ –∑–≤–µ–∑–¥—ã
        for collision in self.collision_points[:100]:
            for idx in collision[:3]:
                ur, uz, Rx, s = self.hypercube[idx]
                
                # –ü–æ–∑–∏—Ü–∏—è –Ω–∞ –æ—Ä–±–∏—Ç–µ
                angle = (ur / n) * 2 * math.pi + pygame.time.get_ticks() / 5000
                distance = 200 + 100 * (uz / n)
                x = center_x + distance * math.cos(angle)
                y = center_y + distance * math.sin(angle)
                
                # –†–∞–∑–º–µ—Ä –∏ —Ü–≤–µ—Ç –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º
                size = 3 + 7 * (s / n)
                color_val = int(255 * Rx / n)
                color = (color_val, 200, 255 - color_val)
                
                pygame.draw.circle(surface, color, (int(x), int(y)), int(size))
                
                # –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π
                if idx != collision[0]:
                    prev_idx = collision[0]
                    pur, puz, pRx, ps = self.hypercube[prev_idx]
                    prev_angle = (pur / n) * 2 * math.pi + pygame.time.get_ticks() / 5000
                    prev_distance = 200 + 100 * (puz / n)
                    px = center_x + prev_distance * math.cos(prev_angle)
                    py = center_y + prev_distance * math.sin(prev_angle)
                    pygame.draw.line(surface, (255, 255, 0), (px, py), (x, y), 1)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        title = font_large.render("–ö—Ä–∏–ø—Ç–æ-–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –¢–µ–ª–µ—Å–∫–æ–ø", True, (220, 180, 255))
        surface.blit(title, (50, 50))
        
        info = font_medium.render(f"–ù–∞–±–ª—é–¥–µ–Ω–∏–µ –∫–ª—é—á–∞ d={self.d} –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ-–≤—Ä–µ–º–µ–Ω–∏", True, (180, 220, 255))
        surface.blit(info, (50, 100))
        
        stats = font_small.render(f"–ß–µ—Ä–Ω–∞—è –¥—ã—Ä–∞ —Ä–∞–¥–∏—É—Å–∞ {black_hole_radius:.1f} | –ö–æ–ª–ª–∏–∑–∏–π: {len(self.collision_points)}", True, (200, 200, 200))
        surface.blit(stats, (50, 140))
    
    def render_quantum(self, surface):
        """–ö–≤–∞–Ω—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º"""
        surface.fill((5, 10, 30))
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–≤–∞–Ω—Ç–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        title = font_large.render("–ö–≤–∞–Ω—Ç–æ–≤–æ–µ –°–æ—Å—Ç–æ—è–Ω–∏–µ –ö–ª—é—á–∞", True, (180, 220, 255))
        surface.blit(title, (50, 50))
        
        # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫—É–±–∏—Ç–æ–≤
        qubit_size = 80
        for i in range(4):
            x = 200 + i * 200
            y = HEIGHT // 2
            
            # –°—Ñ–µ—Ä–∞ –ë–ª–æ—Ö–∞
            pygame.draw.circle(surface, (40, 40, 80), (x, y), qubit_size, 2)
            
            # –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫—É–±–∏—Ç–∞
            state = self.quantum_state[i*2:(i+1)*2]
            prob_0 = abs(state[0])**2
            prob_1 = abs(state[1])**2
            
            # –í–µ–∫—Ç–æ—Ä —Å–æ—Å—Ç–æ—è–Ω–∏—è
            angle = np.angle(state[0]) - np.angle(state[1])
            vec_x = x + qubit_size * 0.8 * prob_0 * math.cos(angle)
            vec_y = y + qubit_size * 0.8 * prob_0 * math.sin(angle)
            
            pygame.draw.line(surface, (0, 200, 255), (x, y), (vec_x, vec_y), 3)
            pygame.draw.circle(surface, (255, 100, 100), (int(vec_x), int(vec_y)), 8)
            
            # –ü–æ–¥–ø–∏—Å–∏
            text = font_small.render(f"–ö—É–±–∏—Ç {i+1}", True, (200, 200, 200))
            surface.blit(text, (x - 30, y + qubit_size + 20))
            
            prob_text = font_small.render(f"|0>: {prob_0:.2f}  |1>: {prob_1:.2f}", True, (150, 255, 150))
            surface.blit(prob_text, (x - 50, y + qubit_size + 50))
        
        # –ó–∞–ø—É—Ç–∞–Ω–Ω–æ—Å—Ç—å
        ent_x, ent_y = WIDTH // 2, HEIGHT - 150
        ent_value = abs(np.vdot(self.quantum_state[:4], self.quantum_state[4:]))
        pygame.draw.circle(surface, (80, 40, 120), (ent_x, ent_y), 60)
        ent_text = font_medium.render(f"–ó–∞–ø—É—Ç–∞–Ω–Ω–æ—Å—Ç—å: {ent_value:.4f}", True, (255, 255, 200))
        surface.blit(ent_text, (ent_x - 120, ent_y - 20))
    
    def render_neural(self, surface):
        """–†–µ–∂–∏–º –Ω–µ–π—Ä–æ–Ω–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞"""
        surface.fill((15, 20, 35))
        
        title = font_large.render("–ù–µ–π—Ä–æ-–¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –ê–Ω–∞–ª–∏–∑ –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏", True, (220, 180, 255))
        surface.blit(title, (50, 50))
        
        # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞—Ä—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        cell_size = 10
        offset_x, offset_y = 100, 150
        
        for ur in range(n):
            for uz in range(n):
                x = offset_x + ur * cell_size
                y = offset_y + uz * cell_size
                
                # –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —É—Ä–æ–≤–Ω—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                security = self.security_map[ur, uz]
                color_val = int(255 * security)
                color = (color_val, color_val, 100)
                
                pygame.draw.rect(surface, color, (x, y, cell_size, cell_size))
        
        # –ê–Ω–∞–ª–∏–∑ —É–≥—Ä–æ–∑
        threat_text, threat_level = self.neural_analysis()
        threat_color = (255, 100, 100) if threat_level > 0.5 else (100, 255, 100)
        
        pygame.draw.rect(surface, (30, 30, 60), (WIDTH - 300, 150, 280, 100))
        threat_title = font_medium.render("–ê–Ω–∞–ª–∏–∑ –£–≥—Ä–æ–∑", True, threat_color)
        surface.blit(threat_title, (WIDTH - 290, 160))
        
        text = font_small.render(threat_text, True, (255, 255, 200))
        surface.blit(text, (WIDTH - 290, 200))
        
        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if threat_level > 0.7:
            advice = "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —É—è–∑–≤–∏–º–æ—Å—Ç—å! –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ —Å–º–µ–Ω–∏—Ç–µ –∫–ª—é—á."
        elif threat_level > 0.4:
            advice = "–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Å–ª–∞–±—ã–µ –º–µ—Å—Ç–∞. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —É—Å–∏–ª–µ–Ω–∏–µ."
        else:
            advice = "–ö–ª—é—á –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –≤—ã—Å–æ–∫—É—é –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ—Å—Ç—å."
        
        advice_surf = font_small.render(advice, True, (200, 200, 255))
        surface.blit(advice_surf, (WIDTH - 290, 230))
    
    def render_poetry(self, surface):
        """–†–µ–∂–∏–º –∫—Ä–∏–ø—Ç–æ-–ø–æ—ç–∑–∏–∏"""
        surface.fill((20, 15, 40))
        
        title = font_large.render("–ö—Ä–∏–ø—Ç–æ-–ü–æ—ç—Ç–∏—á–µ—Å–∫–∞—è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è", True, (220, 180, 255))
        surface.blit(title, (50, 50))
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ—ç–º—ã
        y_pos = 150
        for i, line in enumerate(self.poem_lines):
            color_val = int(200 + 55 * math.sin(i + pygame.time.get_ticks() / 2000))
            color = (color_val, 150, 255)
            line_surf = font_medium.render(line, True, color)
            surface.blit(line_surf, (100, y_pos))
            y_pos += 50
        
        # –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–æ–≤—ã—Ö –ø–æ—ç–º
        pygame.draw.rect(surface, (80, 60, 150), (WIDTH - 250, HEIGHT - 100, 220, 60))
        gen_text = font_medium.render("–ù–æ–≤–∞—è –ü–æ—ç–º–∞", True, (255, 255, 200))
        surface.blit(gen_text, (WIDTH - 240, HEIGHT - 80))
    
    def render_hologram(self, surface):
        """–†–µ–∂–∏–º –≥–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–æ—Ä–∞"""
        surface.fill((5, 5, 20))
        
        title = font_large.render("–ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–µ –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ö–ª—é—á–∞", True, (220, 180, 255))
        surface.blit(title, (50, 50))
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ–ª–æ–≥—Ä–∞–º–º—ã
        hologram_x, hologram_y = WIDTH // 2, HEIGHT // 2
        surface.blit(self.hologram_surface, (hologram_x - 150, hologram_y - 150))
        
        # –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        time_ms = pygame.time.get_ticks()
        for i in range(20):
            angle = i * 2 * math.pi / 20 + time_ms / 2000
            radius = 180 + 20 * math.sin(time_ms / 1000 + i)
            x = hologram_x + radius * math.cos(angle)
            y = hologram_y + radius * math.sin(angle)
            pygame.draw.circle(surface, (0, 200, 255), (int(x), int(y)), 3)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        info = font_medium.render(f"–ì–æ–ª–æ–≥—Ä–∞–º–º–∞ –∫–ª—é—á–∞ d={self.d} mod {n}", True, (180, 220, 255))
        surface.blit(info, (hologram_x - 150, hologram_y + 180))
    
    def render_control_panel(self, surface):
        """–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏–µ–π"""
        # –§–æ–Ω –ø–∞–Ω–µ–ª–∏
        pygame.draw.rect(surface, (30, 25, 60), (0, HEIGHT - 80, WIDTH, 80))
        pygame.draw.line(surface, (80, 60, 150), (0, HEIGHT - 80), (WIDTH, HEIGHT - 80), 3)
        
        # –ö–Ω–æ–ø–∫–∏ —Ä–µ–∂–∏–º–æ–≤
        modes = [
            ("–¢–µ–ª–µ—Å–∫–æ–ø", "telescope"),
            ("–ö–≤–∞–Ω—Ç", "quantum"),
            ("–ù–µ–π—Ä–æ", "neural"),
            ("–ü–æ—ç–∑–∏—è", "poetry"),
            ("–ì–æ–ª–æ–≥—Ä–∞–º–º–∞", "hologram")
        ]
        
        button_width = 180
        for i, (name, mode_id) in enumerate(modes):
            x = 20 + i * (button_width + 10)
            color = (100, 80, 180) if self.mode == mode_id else (60, 50, 120)
            pygame.draw.rect(surface, color, (x, HEIGHT - 70, button_width, 50))
            
            text_color = (255, 255, 200) if self.mode == mode_id else (200, 200, 200)
            text = font_medium.render(name, True, text_color)
            surface.blit(text, (x + button_width//2 - text.get_width()//2, HEIGHT - 55))
        
        # –ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        pygame.draw.rect(surface, (180, 70, 100), (WIDTH - 200, HEIGHT - 70, 180, 50))
        voice_text = font_medium.render("–ì–æ–ª–æ—Å", True, (255, 255, 200))
        surface.blit(voice_text, (WIDTH - 110, HEIGHT - 55))

# –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏–∏
observatory = CosmicCryptoObservatory(d, n)
focus = 1.0

# –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
clock = pygame.time.Clock()
running = True
voice_response = ""
voice_timeout = 0

while running:
    for event in pygame.event.get():
        if event.type == QUIT:
            running = False
        elif event.type == KEYDOWN:
            if event.key == K_ESCAPE:
                running = False
            elif event.key == K_r:
                # –°–ª—É—á–∞–π–Ω—ã–π –∫–ª—é—á
                d = np.random.randint(1, n)
                observatory = CosmicCryptoObservatory(d, n)
            elif event.key == K_SPACE:
                # –ì–æ–ª–æ—Å–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞
                voice_response = observatory.voice_command()
                voice_timeout = 300  # –ü–æ–∫–∞–∑–∞—Ç—å 5 —Å–µ–∫—É–Ω–¥ (60 FPS * 5)
        
        elif event.type == MOUSEBUTTONDOWN:
            x, y = event.pos
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–Ω–æ–ø–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            if WIDTH - 200 <= x <= WIDTH - 20 and HEIGHT - 70 <= y <= HEIGHT - 20:
                voice_response = observatory.voice_command()
                voice_timeout = 300
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–Ω–æ–ø–æ–∫ —Ä–µ–∂–∏–º–æ–≤
            if HEIGHT - 70 <= y <= HEIGHT - 20:
                button_width = 180
                for i in range(5):
                    x_start = 20 + i * (button_width + 10)
                    if x_start <= x <= x_start + button_width:
                        modes = ["telescope", "quantum", "neural", "poetry", "hologram"]
                        observatory.mode = modes[i]
            
            # –ö–Ω–æ–ø–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ—ç–º—ã
            if observatory.mode == "poetry" and WIDTH - 250 <= x <= WIDTH - 30 and HEIGHT - 100 <= y <= HEIGHT - 40:
                observatory.generate_poem()
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –≤–≤–æ–¥–∞
    keys = pygame.key.get_pressed()
    if keys[K_w]:
        focus = min(focus + 0.05, 5.0)
    if keys[K_s]:
        focus = max(focus - 0.05, 0.1)
    
    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    observatory.update(focus)
    
    # –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    observatory.render(screen)
    
    # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
    if voice_timeout > 0:
        pygame.draw.rect(screen, (40, 30, 80), (WIDTH//2 - 200, 20, 400, 60))
        pygame.draw.rect(screen, (100, 80, 180), (WIDTH//2 - 200, 20, 400, 60), 3)
        response_text = font_medium.render(voice_response, True, (255, 255, 200))
        screen.blit(response_text, (WIDTH//2 - response_text.get_width()//2, 40))
        voice_timeout -= 1
    
    # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞
    pygame.display.flip()
    clock.tick(60)

pygame.quit()
sys.exit()
```

### –ß—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –ö—Ä–∏–ø—Ç–æ-–ö–æ—Å–º–∏—á–µ—Å–∫—É—é –û–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏—é:

1. **–ü—è—Ç—å —Ä–µ–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤**:
   - üî≠ **–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π —Ç–µ–ª–µ—Å–∫–æ–ø**: –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∫–ª—é—á–∞ –∫–∞–∫ —á–µ—Ä–Ω–æ–π –¥—ã—Ä—ã —Å –∫–æ–ª–ª–∏–∑–∏—è–º–∏-–∑–≤–µ–∑–¥–∞–º–∏
   - ‚öõÔ∏è **–ö–≤–∞–Ω—Ç–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä**: –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–ª—é—á–∞ –∫–∞–∫ —Å–∏—Å—Ç–µ–º—ã –∑–∞–ø—É—Ç–∞–Ω–Ω—ã—Ö –∫—É–±–∏—Ç–æ–≤
   - üß† **–ù–µ–π—Ä–æ-—Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑**: –ö–∞—Ä—Ç–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–µ–π —É–≥—Ä–æ–∑
   - üìú **–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫—Ä–∏–ø—Ç–æ-–ø–æ—ç–∑–∏–∏**: –ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏–∫–∏ –≤ –ø–æ—ç–∑–∏—é
   - üåå **–ì–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–µ–∫—Ç–æ—Ä**: 3D-–ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞ –∫–∞–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–æ–Ω–Ω–æ–π –∫–∞—Ä—Ç–∏–Ω—ã

2. **–ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
   - –ö–æ–º–∞–Ω–¥—ã: "—Å–º–µ–Ω–∏—Ç—å –∫–ª—é—á", "—Ä–µ–∂–∏–º —Ç–µ–ª–µ—Å–∫–æ–ø", "–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ—ç–∑–∏–∏"
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏
   - –ì–æ–ª–æ—Å–æ–≤–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º

3. **–ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–π –∞–Ω–∞–ª–∏–∑ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏**:
   - –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –∫–æ–ª–ª–∏–∑–∏–π —Å –ø–æ–º–æ—â—å—é DBSCAN
   - –û—Ü–µ–Ω–∫–∞ —É—Ä–æ–≤–Ω—è —É–≥—Ä–æ–∑—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–æ–ø–æ–ª–æ–≥–∏–∏
   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É—Å–∏–ª–µ–Ω–∏—é –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏

4. **–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞**:
   - –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ–∑–¥–∞–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –≥–æ–ª–æ–≥—Ä–∞–º–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª—é—á–∞
   - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ-–ø–æ—ç–∑–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–ª—é—á–∞
   - –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏, —Ä–µ–∞–≥–∏—Ä—É—é—â–∏–µ –Ω–∞ —Ñ–æ–∫—É—Å –∏ –≤—Ä–µ–º—è

5. **–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
   - –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–≤ –æ–¥–Ω–∏–º –∫–ª–∏–∫–æ–º
   - –ö–Ω–æ–ø–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏—è
   - –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏

### –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:

1. **–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–æ–≤**:
   - –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫–∏ –≤ –Ω–∏–∂–Ω–µ–π –ø–∞–Ω–µ–ª–∏: –¢–µ–ª–µ—Å–∫–æ–ø, –ö–≤–∞–Ω—Ç, –ù–µ–π—Ä–æ, –ü–æ—ç–∑–∏—è, –ì–æ–ª–æ–≥—Ä–∞–º–º–∞
   - –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–æ–ª–æ—Å–æ–≤—É—é –∫–æ–º–∞–Ω–¥—É: "—Ä–µ–∂–∏–º [–Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ–∂–∏–º–∞]"

2. **–ì–æ–ª–æ—Å–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ**:
   - –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É "–ì–æ–ª–æ—Å" –∏–ª–∏ –ø—Ä–æ–±–µ–ª
   - –ü—Ä–æ–∏–∑–Ω–µ—Å–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É: 
     - "—Å–º–µ–Ω–∏—Ç—å –∫–ª—é—á" - —Å–ª—É—á–∞–π–Ω—ã–π –Ω–æ–≤—ã–π –∫–ª—é—á
     - "—Ä–µ–∂–∏–º —Ç–µ–ª–µ—Å–∫–æ–ø" - –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞
     - "–Ω–æ–≤–∞—è –ø–æ—ç–∑–∏—è" - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏—è

3. **–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã**:
   - –í —Ä–µ–∂–∏–º–µ –ø–æ—ç–∑–∏–∏: –Ω–∞–∂–º–∏—Ç–µ "–ù–æ–≤–∞—è –ü–æ—ç–º–∞" –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
   - –í –∫–≤–∞–Ω—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∞–≤–∏—à–∏ 1-4 –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∫–≤–∞–Ω—Ç–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
   - –í–æ –≤—Å–µ—Ö —Ä–µ–∂–∏–º–∞—Ö: W/S –¥–ª—è —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∫–∏ —Ñ–æ–∫—É—Å–∞

–≠—Ç–∞ –æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏—è –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –∞–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –≤ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—â–µ–µ –º—É–ª—å—Ç–∏—Å–µ–Ω—Å–æ—Ä–Ω–æ–µ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ —á–µ—Ä–µ–∑ –∫–æ—Å–º–æ—Å, –∫–≤–∞–Ω—Ç–æ–≤—ã–µ –º–∏—Ä—ã –∏ –ø–æ—ç—Ç–∏—á–µ—Å–∫–∏–µ –≤—Å–µ–ª–µ–Ω–Ω—ã–µ!